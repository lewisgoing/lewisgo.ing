---
title: 'Chinese Remainder Theorem, Carnival Games and 2048-bit Integers'
description: "Guessing a 617-digit integer using ancient math! A journey through number theory, carnival games, and cryptography in AmateursCTF 2023."
date: 2023-07-24
tags: ['programming', 'algorithm', 'number-theory', 'ctf']
images: ['/projects/crt/banner.webp', '/projects/crt/2048.svg', '/projects/crt/visualization.svg']
status: 'completed'
completedDate: 'July 2023'
technologies: ['Python', 'Number Theory', 'Cryptography', 'CTF']
category: 'research'
featured: true
githubUrl: 'https://github.com/yourusername/crt-solver'
---

## Introduction

High school CTF team [View Source](https://ctftime.org/team/175828) and I participated in [AmateursCTF 2023](https://ctftime.org/event/1983), placing 2nd both overall and in the student division. Although there were over 64 challenges to tackle throughout the four-day submission period, I personally only put emphasis on the OSINT and algorithm categories. Within these categories lay an interesting challenge: the `gcd-query` series, which I solved with an implementation of a very special algorithm. This was my process (paired alongside a lengthy analogy)!

---

## gcd-query-v1

<Challenge
  authors={['skittles1412']}
  solvers={[
    {
      name: 'enscribe',
      href: 'https://github.com/jktrn',
      avatar: 'https://github.com/jktrn.png',
    },
  ]}
  category="PPC"
  points={475}
  solves={43}
>
  I wonder if this program leaks enough information for you to get the flag with
  less than 2048 queries... It probably does. I'm sure you can figure out how.
  `nc amt.rs 31692`
</Challenge>

We're initially provided with an attachment `main.py` and a remote server `amt.rs:31692`. The server component contains the following:

```python title="main.py" caption="v1 Attachment" showLineNumbers
#!/usr/local/bin/python
from flag import flag
from math import gcd
from Crypto.Util.number import getRandomInteger

for i in range(10):
    x = getRandomInteger(2048)
    for i in range(1412):
        try:
            n, m = map(int, input("n m: ").split())
            assert m > 0
            print(gcd(x + n, m))
        except:
            print("bad input. you *die*")
            exit(0)
    if int(input("x: ")) != x:
        print("get better lol")
        exit(0)

print(flag)
```

Let's go over step-by-step what this server is up to:

- For ten iterations, a long `x` is created by pycrypto's [`getRandomInteger(n)`](https://pythonhosted.org/pycrypto/Crypto.Util.number-module.html#getRandomInteger), which returns a random integer with up to $n$ bits in length. $n = 2048$; this is an absolutely mindbendingly large number—up to 617 digits long! You absolutely do not want to see what 617 digits looks like in decmimal:

![2048-bit Visual](/projects/crt/2048.svg)

- For each iteration of `x`, the user gets prompted to enter two integers `n` and `m`. Once the assertion that `m > 0` is passed, `n` and `m` are passed into a function `gcd(x + n, m)`, which returns the **greatest common divisor** of `x + n` and `m`. This occurs for 1412 iterations.
- After the iterations have completed, the user is then prompted to guess the value of `x`. If the guess is correct, the next iteration of `x` begins. This process is repeated nine more times until the flag is printed.

Here is a quick visual depicting what's going on:

![Source Code Graphical Visualization](/projects/crt/visualization.svg)

Paying close attention to the right side of this graphic, we can see that there's only a couple specific points at which we can interact with the server: when we pick the `n` and `m` to send, and when we guess the value of `x`. The question now is: what values should we be picking for `n` and `m` which reveal the most information about `x`, and how do we use this information to obtain its actual value?

### The Chinese Remainder Theorem

<InfoBox type="info">
  **Recall**: The *modulus* is the remainder of [Euclidian division](https://en.wikipedia.org/wiki/Euclidean_division) (division with remainder) of one number by another. For example, $$2 = 12 \pmod{5}$$.

  However, this is different from the **congruence modulo** relation, represented by the congruence symbol $$\equiv$$ and often expressed as $$a \equiv b \pmod{m}$$. When two numbers $$a$$ and $$b$$ are congruent modulo $$m$$, it means that:
  
  1. $$a$$ and $$b$$ have the same remainder when divided by $$m$$
  2. $$a - b$$ is divisible by $$m$$ (i.e. $$m \mid (a - b)$$)
  3. There is an integer $$k$$ such that $$a = km + b$$
  
  As such, $$12 \equiv 2 \pmod{5}$$ is true, but $$12 = 2 \pmod{5}$$ is obviously false.
</InfoBox>

We start with a concept called a "system of congruences." A system of congruences is a set of equations of the form $$x \equiv a_i \pmod{m_i}$$, where $$a_i$$, $$b_i$$, and $$m_i$$ are integers. The $$m_i$$ values are called the **moduli** of the system. Here's a quick example of this:

$$
\begin{cases}
x &\equiv 1 \pmod{2} \\
x &\equiv 2 \pmod{3} \\
x &\equiv 3 \pmod{5}
\end{cases}
$$

In this system, we have three congruences with moduli $$2$$, $$3$$, and $$5$$. The goal is to find a value for $$x$$ that satisfies all three congruences simultaneously.

Thus, we can apply the Chinese Remainder Theorem:

<InfoBox>
  **Chinese Remainder Theorem**: Given pairwise coprime integers $$n_1, n_2, \ldots, n_k$$ and arbitrary integers $$a_1, a_2, \ldots, a_k$$, the system of simultaneous congruences
  $$
  \begin{cases}
  x &\equiv a_1 \pmod{n_1} \\
  x &\equiv a_2 \pmod{n_2} \\
  \vdots \\
  x &\equiv a_k \pmod{n_k}
  \end{cases}
  $$
  has a solution, and the solution is unique modulo $$N = n_1 n_2 \cdots n_k$$.
</InfoBox>

<InfoBox type="info">
  **Note**: Although the Chinese Remainder Theorem is often stated with pairwise coprime moduli (meaning that for a set of moduli $$M = \{n_1, n_2, \ldots, n_k\}$$, $$\gcd(n_i, n_j) = 1$$ for all $$i \neq j$$), it can be extended to non-coprime moduli. However, doing so does not guarantee a solution — this will become increasingly relevant as we get towards our implementation process.
</InfoBox>

You may be asking: what the hell does this have to do with guessing the giant integer that we've been given? Well, I've concocted a little example here to demonstrate how we can use this theorem to our advantage.

### Tne Modular Arithmetic Nerd's Favorite Carnival Game

![Carnival Game](/projects/crt/carnival-visual.svg)

Let's say little Bob over at the bottom right goes to a carnival game booth and is asked to guess a number on a ball behind the operator. Obviously, since we're omnipotent observers in this fantastical 2D universe of cute little cartoon circle people, we know that the number is $$x = 727$$. However, Bob doesn't know this. He's really good at modular arithmetic though, so he'll have a lot of fun with this one.

Bob's told that he can give the operator a piece of paper with two integers of his arbitrary choice: `n` and `m`. As long as `m` is above 0, the operator will always give him back a piece of paper with `n` and `m` passed into `gcd(x + n, m)`. However, the operator's shift is about to end soon, and he estimates that he'll probably accept only about three pieces of paper from Bob until he closes shop.

Bob goes back to his table. He's flabbergasted. How in the world is he going to guess that number with only three pieces of information?

He rummages around his little noggin and recollects himself. Let's see what he's thinking:

![Bob Thinking](/projects/crt/bob-thinking.svg)

Uh... thanks, I guess? Well, he has a good point, but since I guarantee that nobody read it (because it's too long for the average CTF player's attention span) I'll give a brief TL;DR here.

Bob's saying that per the definition of a "greatest common divisor," in the scenario $$d = \gcd(a, b)$$, both $$a \pmod{d} = 0$$ and $$b \pmod{d} = 0$$ is true. Since we're given the function `d = gcd(x + n, m)`, we can therefore say that $$(x + n) \pmod{d} = 0$$ and $$m \pmod{d} = 0$$.

We can introduce an integer $$k$$ into the mix and rewrite $$(x + n) \pmod{d} = 0$$ as $$\frac{(x + n)}{d} = k$$. Let's algebraify this up to get to the state that we want it to:

$$
\frac{(x + n)}{d} = k \\
(x + n) = kd \\
x \equiv kd - n \pmod{d} \\
x \equiv -n \pmod{d}
$$

Replacing $d$ with the `gcd()` function:

$$
x \equiv -n \pmod{\gcd(x + n, m)}
$$

Doesn't that look very, very familiar to the system of congruences that we were talking about earlier? Now, all we need to do is decide what values of $n$ and $m$ to pick.

Bob's decided that his three attempts is nowhere near enough attempts to do anything reasonable with a fixed offset $$n$$. He's discovered something a bit more clever: **what if you changed the value of $$n$$ every time?** In doing so, it provides information about the offset from 0 modulo that GCD. He's selected the following values for $$n$$:

$$
\begin{cases}
n_1 &= 0 \\
n_2 &= -1 \\
n_3 &= -2
\end{cases}
$$

<InfoBox type="info">
  **Note**: Bob's chosen negative values for $$n_2$$ and $$n_3$$ because of the earlier relation established, $$x \equiv -n \pmod{\gcd(x + n, m)}$$. Making $$n$$ negative creates positive remainders.
</InfoBox>

For $$m$$, Bob chooses a very large **primorial**:

<InfoBox>
  For the $$n$$th prime number $$p_n$$, the primorial $$p_n\#$$ is defined as the product of the first $$n$$ primes:
    
  $$
  p_n\# = \prod_{k=1}^n p_k
  $$

  where $$p_k$$ is the prime number.
</InfoBox>

Primorials have the special property in that since they're the product of the first $$n$$ primes, they're guaranteed to have a lot of prime factors. When thrown into the `gcd()` function, this will give us tons of information about the prime factors of $$x$$ since we're a lot more likely to get a hit (a miss would be if $$\gcd(x + n, m) = 1$$).

Bob's ended up deciding on $$m = p_{11}\#$$. He pulls out his laptop and calculates it with Python:

```python title="primorial.py" caption="v1 Primorial Calculation" showLineNumbers
from operator import mul
from sympy import prime
from functools import reduce

N = 11

product = lambda arr: reduce(mul, arr)
primes = lambda n: [prime(i) for i in range(1, n + 1)]

primorial = product(primes_list := primes(N))
print(primes_list)
print(primorial)
```

```bash
$ python3 primorial.py
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]
200560490130
```

Bob's now ready to go! He walks up to the operator and hands him his pieces of paper. The operator hastily hands him back three pieces of paper with the resulting GCDs:

![Bob Handing Papers](/projects/crt/handing-papers.svg)

Now he knows that:

$$
\begin{cases}
x \equiv 0 \pmod{1} \\
x \equiv 1 \pmod{66} \\
x \equiv 2 \pmod{145}
\end{cases}
$$

and he can apply the Chinese Remainder Theorem to solve for $$x$$. Bob opens back up his laptop and runs the following code:

```python title="crt.py" caption="CRT Implementation" showLineNumbers
from sympy.ntheory.modular import crt

remainders = [0, 1, 2]
moduli = [1, 66, 145]

print(crt(moduli, remainders)[0] if crt(moduli, remainders) else None)
```

```bash
$ python3 crt.py
727
```

Bob's got the number! Congratulations, Bob!

![Congrats, Bob!](/projects/crt/congrats-bob.svg)

### Implementation

Hopefully through this example, you've gained a bit of intuition on where CRT is derived from, why we chose those particular values, and why it works. Now, let's apply this to the actual challenge.

Here is the script that I used to solve this challenge. It's very straightforward and readable in comparison to other scripts I've seen, so I felt it was redundant to go through the step-by-step process. I've added comments to explain what's going on.

```python title="solve.py" caption="v1 Solve" showLineNumbers
from sympy.ntheory.modular import crt
from sympy import primorial
from tqdm import tqdm
from pwn import *

# Generate the 256th primorial
N = 2**8
primorial = primorial(N)

p = remote('amt.rs', 31692)

for _ in range(10):
    remainders = []
    moduli = []

    for j in tqdm(range(1412)):
        n = -j
        m = primorial
        p.sendlineafter(b'n m: ', bytes(f'{n} {m}', 'utf-8'))

        # Append positive j and the GCD result to remainders and moduli
        remainders.append(j)
        moduli.append(int(p.recvlineS()))

    # Apply Chinese Remainder Theorem on the generated congruence system
    result = crt(moduli, remainders)[0]
    log.info(f'Guessing result {result}...')
    p.sendlineafter(b'x: ', bytes(str(result), 'utf-8'))

log.success(p.recvallS())
```

Let's run the script on the remote server:

```bash
$ python3 solve.py
[+] Opening connection to amt.rs on port 31692: Done
100%|████████████████████████████████████| 1412/1412 [01:40<00:00, 14.04it/s]
[*] Guessing result 13811095902755644846482198689370064280419582878881370588339407663501153